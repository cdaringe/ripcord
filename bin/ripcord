#!/usr/bin/env node

'use strict'

const app = require('../src/app')
const program = require('commander')
const path = require('path')
const pkgPath = path.resolve(__dirname, '../package.json')
const pkg = require(pkgPath)
const ripcord = require('../src/')
const counsel = require('counsel')
const postProcessReport = require('./post-process-report')

// CLI command metadata. `name` refers to a corresponding function in
// ripcord's library entry point (ref, src/index.js)
let action = { name: null, arg: null, options: null }

// attempt usage of local ripcord, if present
try {
  let localRipcordFilename = path.join(process.cwd(), 'node_modules', 'ripcord', 'bin', 'ripcord')
  localRipcordFilename = require.resolve(localRipcordFilename)
  if (__filename !== localRipcordFilename) return require(localRipcordFilename)
} catch (err) { /* pass */ }

// expose and digest CLI
program
  .version(pkg.version)
program
  .option('-l, --log-level [error|warn|info|verbose|debug|silly]', 'set the log level. default info')
  .option('--verbose', 'set the log level to verbose')

program
  .command('report')
  .option('-o, --output <dir|filename>', 'path to dump the report')
  .description('generate tripwire dependency report')
  .action((arg, opts) => { action = { name: 'report', arg: arg, options: opts } })

program
  .command('counsel <apply|check>')
  .description('deploy tripwire project conventions via counsel')
  .action((arg, opts) => { action = { name: 'counsel', arg: arg, options: opts } })

program
  .command('licenses <check|dump>')
  .option('-f, --force', 'force dep report, even if package marked as `devOnly`')
  .option('-o, --output <dir|filename>', 'output to dir or to file when check fails, or on dump request')
  .option('-c, --csv', 'csv output. output mode defaults to JSON')
  .option('-d, --dev', 'inlcude package licenses')
  .description([
    'check or dump project licenses. ONLY outputs licenses for `dependencies`',
    'not `devDependencies` by default.'
  ].join(' '))
  .action((arg, opts) => { action = { name: 'licenses', arg: arg, options: opts } })

program
  .command('sync-packages')
  .option('-d, --dry-run', 'show packages to copy')
  .description('sync packages from external npm repo to internal repo')
  .action((arg, opts) => { action = { name: 'syncPackages', arg: arg, options: opts } })

program
  .command('scmcycle')
  .description('exec scmcycle')
  .action((arg, opts) => { action = { name: 'scmcycle', arg: arg, options: opts } })

program.parse(process.argv)


// validate command line input
const args = program.args ? program.args.filter(a => a) : []
const hasArgs = args && args.length > 0
const isValidArg = hasArgs ? (args[0] instanceof program.Command || args[1] instanceof program.Command)  : false
if (!hasArgs || !isValidArg) {
  ripcord.logger.error('invalid args passed')
  program.outputHelp()
  process.exit(1)
}

// configure logger
counsel.logger.transports.console.level = program.verbose ? 'verbose' : program.logLevel || app.logLevel
ripcord.logger.setLogLevel(program.logLevel || app.logLevel)

// go.
const cmdP = ripcord[action.name].apply(ripcord, [action.arg, action.options || {}])
Promise.resolve(cmdP)
.then(result => {
  if (action.name === 'report') postProcessReport(action, result)
})

module.exports = program
